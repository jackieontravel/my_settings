# Setup handy aliases in the embedded Linux environments through XShell.
#
# NOTE 1: 
#   This is template file, it will be converted to a actual command file by adding a current time command by Batch file.
#   During this conversion, only the '#' in the first character of a line will be treated as comment and won't be passed to the actual command file.
#
# NOTE 2: Tricks on 'date' and timezone
#   Since the target may have no timezone info under '/usr/share/zoneinfo', so we cannot set /etc/localtime correctly.
#   Under such condition the simply TZ settings like TZ='CST-8' works for utilities like 'ls', but not 'date' or system time (history w/ timestamp).
#   So, I re-generate a simplified Asia/Taipei (CST) tomezone, save to /etc/localtime. The script is generated by the following command on Turtle:
#      echo "Zone CST 8:00 - CST">tzF && zic -d. tzF && rm -rf tzF \
#      && hexdump CST -e '/1 "%02X"' -v| sed -e 's/../\\\\x&/g' > strF  && \
#      echo && echo "echo -n -e \"$(cat strF)\" >/etc/localtime;" && rm -rf strF
#   The basic idea is: Create a very simple timezone description file tsF, then generate the conversion file by 'zic',
#   Then use 'hexdump' and sed to convert this binary file to text so that we can use echo to convert back in target board.
# NOTES on NOTE:
#   Basically use strace to find out which files are referenced.
export PS1="\[\e[35;1m\][\! \D{%m/%d %T} \u@\H \w]\n\$ \[\e[0m\]"
export COLUMNS=120
export TERM=xterm
export HISTTIMEFORMAT='%m/%d %T '
alias  h='function __h()  { history ${1:-15}; }; __h '
alias hh='function __hh() { history ${1:-50}; }; __hh '
alias ll='/bin/ls -Al --color=always'
alias llc='/bin/ls -l --color=always'
alias lll='/bin/ls -l --color=always'
alias ls='/bin/ls -A --color=always '
alias lsc='/bin/ls --color=always'
alias lls='/bin/ls --color=always'
alias lm='function __lm() { ls -Al --color=always $* |more; }; __lm '
alias la='/bin/ls -al --color=always'
alias md='mkdir'
alias grep='grep --color'
if [ ! -f /etc/localtime ]; then 
echo -n -e "\\x54\\x5A\\x69\\x66\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\x00\\x00\\x70\\x80\\x00\\x00\\x43\\x53\\x54\\x00\\x00\\x00\\x54\\x5A\\x69\\x66\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x04\\x00\\x00\\x70\\x80\\x00\\x00\\x43\\x53\\x54\\x00\\x00\\x00\\x0A\\x43\\x53\\x54\\x2D\\x38\\x0A" >/etc/localtime;
fi

### Handy functions to calculate disk usage 
#################################################################################
### shell function to find file
### Usage:
###      duu        #= du --max-depth=1
###      duu 2      #= du --max-depth=2
###      duu -h     #= du --max-depth=1 -h
###      duu 2 -h   #= du --max-depth=2 -h
###      duu 0 -h   #= du -s -h
### NOTE:
###      1. first argument is used to assign --max-depth=N, and can be omitted.
###      2. 'sudo' is always needed to avoid 'Permission denied'
function duu() 
{ 
    re='^[0-9]+$'
    if [[ $1 =~ $re ]] ; then
        # $1 is a number, remove leading space then assign to variable d.
        d=$(sed -e 's/^[[:space:]]*//' <<<$1);
        shift
    else
        d=1
    fi
    
    du --max-depth=$d "$@"; 
};

function duuh() 
{ 
    duu "$@" -h 
};

function duus() 
{ 
    duu "$@" | sort -n
};


####################################################################################################
####################################################################################################
## Elapsed time derived from build.bash
# Set the starting time to calculate elpased time
function st()
{
    # To provide the elapsed time for a build, first save the current time.
    start_time=`date '+%j %H %M %S'`
    stfrom=`date`
}

#----------------------------------------------------------------------------
# Compute and print the elapsed time.
#    Input - start_time must be set by st
function et()
{
    # Get and print the elapsed time for this build job.
    echo -e "===\nStarted from:\n$stfrom"
    end_time=`date '+%j %H %M %S'`
    echo "$end_time $start_time" | awk '{et=((($1*24+$2)*60+$3)*60+$4)-((($5*24+$6)*60+$7)*60+$8);es=et%60;em=int(et/60);printf ("\n===> Elapsed time  %dm %02ds\n\n",em,es)}'
    date
}

#----------------------------------------------------------------------------
# A simple script to generate index.html to list directory
function gen_index()
{
    if [ $# -gt 0 ]; then
        D="$1"
    else
        D="."
    fi
    
    # Use /bin/ls to avoid alias of 'ls'
    for F in $(/bin/ls $D) ; do echo "<li><a href=\"${F}\">${F}</a></li>" ; done > $D/index.html
    
    echo "$D/index.html generated"
}


# Colorful grep: highlight the keywords and keep output others, especially useful in embedded system with full-function grep
function cgrep1()
{
    GREP_COLORS="ms=01;31" grep --color=always -E "$1|$"
}

function cgrep2()
{
    GREP_COLORS="ms=01;32" grep --color=always -E "$1|$"
}

function cgrep3()
{
    GREP_COLORS="ms=01;33" grep --color=always -E "$1|$"
}

function cgrep4()
{
    GREP_COLORS="ms=01;34" grep --color=always -E "$1|$"
}

function cgrep5()
{
    GREP_COLORS="ms=01;35" grep --color=always -E "$1|$"
}

function cgrep6()
{
    GREP_COLORS="ms=01;36" grep --color=always -E "$1|$"
}

function cgrep()
{
    if [ $# -lt 1 ]; then
        echo "Usage: cgrep [<pattern> [pattern2]...[pattern6]]"
        return
    fi
    
    cmd="cgrep1 $1"
    shift
    
    if [ $# -ge 1 ]; then
        cmd="$cmd | cgrep2 $1"
        shift
    fi
    
    if [ $# -ge 1 ]; then
        cmd="$cmd | cgrep3 $1"
        shift
    fi
    
    if [ $# -ge 1 ]; then
        cmd="$cmd | cgrep4 $1"
        shift
    fi
    
    if [ $# -ge 1 ]; then
        cmd="$cmd | cgrep5 $1"
        shift
    fi
    
    if [ $# -ge 1 ]; then
        cmd="$cmd | cgrep6 $1"
        shift
    fi
    
    eval $cmd
}


#colorful grep variants: highlight the whole line with background color: format cgrep<n>l. 'l' stands for line
# TODO: Not a perfect solution yet, now highlight to the end of line, we need just the pattern itself
# More possibility: http://stackoverflow.com/questions/17236005/grep-output-with-multiple-colors
function cgrep1l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep1 "$1.*"
}

function cgrep2l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep2 "$1.*"
}

function cgrep3l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep3 "$1.*"
}

function cgrep4l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep4 "$1.*"
}

function cgrep5l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep5 "$1.*"
}

function cgrep6l()
{
    GREP_COLORS="ms=0;30;100" grep --color=always -E "^.*$1.*$|$" | cgrep6 "$1.*"
}
